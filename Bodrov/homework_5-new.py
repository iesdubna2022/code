import numpy as np
'''
    определённый интеграл от функции sin^2(x)*sin(x^2)*exp(-x^2) от 0 до 3
    по идее примерно равно 0,1667
'''
#------------------- РАЗБОР КОДА НИКИТЫ ХОБОТНЕВА ---------------------------------------------------

def f(x): #ИСХОДНАЯ ФУНКЦИЯ
    return ((np.sin(x))**2) * np.sin(x**2) * np.exp(-(x**2))

def definitIntegral(func, lower, upper, numOfSegm) -> float:#ЗДЕСЬ МЫ ПИШЕМ ШАПКУ ФУНКЦИИ ИНТЕГРАЛА, 
    #ПАРАМЕТРАМИ КОТОРОГО ЯВЛЯЮТСЯ: сама функция, начало отрезка, конец отрезка и количество сегментов (разбиений)
    step = ((upper-lower)*1.) / numOfSegm #здесь мы задаём шаг , а это есть длина отрезка, делённая на количество разбиений
    x = np.arange(lower, upper, step)#здесь мы генерируем отрезки от минимума к максимума на основе шага,
    # с которым мы "движемся" и этот всё массивб кстати тут ещё можно и иногда нужно добавить 4 параметр тип возвращаемого значения
    # но тут и так это определяется из lower, upper, step
    x = np.array(x+(step*1.)/2)# здесь мы уже преобразуем массив, прибавляя к Х пол шага: ЭТО ДЕЛАЕТСЯ ДЛЯ ТОГО, ЧТОБЫ
    # брать центр прямоугольника
    x = np.array(func(x))# тут уже мы эти "ИКСЫ" , кототые являются центрами основания малой ширины прямоугольников и засовываем в функцию
    z = np.array(step*x)# и тут мы все эти высоты прямоугольников (значение функции от середин шагов через шаг) умножаем на шаг,чтобы получить площадь прямоугольников
    return z.sum()# и наконец суммируем все члены массива (площади прямоугольников) и получаем приближенное значение интеграла от данной функции 

print(
    definitIntegral(f, 0, 3, 1_000_000)# РЕАЛИЗАЦИЯ
)

#------------------------------------------------------------------------------------------------------------------


#----------------- МОЙ НЕМНОГО ПЕРЕДЕЛАННЫЙ КОД -------------------------------------------------------------------

def my_integral(function, x_min, x_max, N) -> float:
    step = ((x_max - x_min)*1.) / N # ОПРЕДЕЛЯЮ ШАГ
    X = np.linspace(x_min, x_max, N)# тут я уже взял другую функцию , которая генерирует N точек от x_min до x_max
    S = np.array((function(X)+function(X+(step*1.)))/2*step) # реализация метода трапеций
    return S.sum()# суммирование площадей трапеций для нахождения интеграла


print(
    my_integral(f, 0, 3, 1_000_000) # РЕАЛИЗАЦИЯ
)
#------------------------------------------------------------------------------------------------------------------
        
#----------МОНТЕ КАРЛО-ПОПЫТКА-------------------------------------------------------------------------------------------
def my_integral(function, x_min, x_max, Q) ->float:
    step = ((x_max - x_min)*1.) / Q # ОПРЕДЕЛЯЮ ШАГ
    max=0.
    min=1000000000
    X = np.arange(x_min, x_max, step/5)
    x = np.random.choice(X, Q)
    for i in x:
        if function(i)>max:
            max = function(i)
        if function(i)<min:
            min = function(i)
    Y = np.arange(0, max, step/5)
    y = np.random.choice(Y, Q)
    key=0
    n=0
    N=0
    for i in x:
        if function(i)>=Y[key]:# не нашел метода в numpy ля этого
            n = n + 1
        N = N + 1
    S = np.abs(max-min)*(x_max - x_min)
    res = S*n/N
    return res
